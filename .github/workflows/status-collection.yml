name: status collection

# =============================================================================
# 🚀 GitHub Actions ワークフロー設定（マスター設定）
# =============================================================================
# このファイルは稼働.comシステムの実行スケジュールと設定の「マスター設定」です。
# 
# 📋 設定の優先順位:
# 1. GitHub Actions実行時: このワークフローファイルの設定が適用
# 2. ローカル実行時: config/config.yml の設定が適用
# 
# ⚠️  重要: 設定変更時は以下のファイルとの同期を保ってください:
# - config/config.yml (scheduling.status_collection_interval: 120分)
# - batch/utils/config.py (SchedulingConfig.status_collection_interval: 120分)
# =============================================================================

# トリガー設定
on:
  schedule:
    # 🕐 稼働状況収集: 2時間ごと実行（config.ymlと統一）
    # cron式の読み方: '分 時 日 月 曜日'
    # '0 */2 * * *' = 毎日、2時間おき（0:00, 2:00, 4:00, 6:00, 8:00, 10:00, 12:00, 14:00, 16:00, 18:00, 20:00, 22:00）に実行
    # */2 は「2で割り切れる時間」を意味するため、確実に2時間間隔で実行されます
    - cron: '0 */2 * * *'
  workflow_dispatch:  # 手動実行も可能
    inputs:
      job_type:
        description: '実行するジョブタイプ'
        required: true
        default: 'status-collection'
        type: choice
        options:
        - status-collection
        - debug-html
      log_level:
        description: 'ログレベル（固定：DEBUG）'
        required: false
        default: 'DEBUG'
        type: choice
        options:
        - DEBUG
      force_immediate:
        description: 'Status Collection即時実行（待機時間をスキップ）'
        required: false
        default: false
        type: boolean

# ジョブタイプ別の並列実行制御
concurrency:
  group: ${{ github.workflow }}-${{ github.event.inputs.job_type || 'status-collection' }}-${{ github.ref }}
  cancel-in-progress: true  # 同じジョブタイプの重複実行をキャンセル

jobs:
  batch-execution:
    name: バッチジョブ実行
    runs-on: ubuntu-latest
    timeout-minutes: 720  # 12時間（スケジュール実行のため）
    
    steps:
    - name: リポジトリのチェックアウト
      uses: actions/checkout@v4
      with:
        fetch-depth: 1  # 最新のコミットのみ取得
    
    - name: Python環境のセットアップ
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        cache-dependency-path: 'requirements.txt'

    - name: 依存関係のインストール
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        # 開発用依存関係があれば追加
        # pip install -r requirements-dev.txt
    
    - name: 設定ファイルの作成
      working-directory: batch
      run: |
        # 設定ディレクトリの作成
        mkdir -p config
        
        # secret.ymlファイルの作成（環境変数から）
        cat > config/secret.yml << 'EOF'
        database:
          password: "${{ secrets.DB_PASSWORD }}"
          url: "${{ secrets.DATABASE_URL }}"
        
        auth:
          secret_key: "${{ secrets.JWT_SECRET_KEY }}"
        
        # x_api設定は削除済み
        EOF
        
        # ファイルの権限設定（セキュリティ強化）
        chmod 600 config/secret.yml
    
    - name: データベース接続テスト
      working-directory: batch
      env:
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        LOG_LEVEL: ${{ github.event.inputs.log_level || 'INFO' }}
        PYTHONPATH: ${{ github.workspace }}/batch
      run: |
        echo "データベース接続テストを開始します..."
        echo "現在のディレクトリ: $(pwd)"
        echo "Pythonパス: $PYTHONPATH"
        ls -la
        
        python -c "
        import sys
        import logging
        import os
        
        # ログレベルの設定
        log_level = os.getenv('LOG_LEVEL', 'INFO')
        logging.basicConfig(level=getattr(logging, log_level))
        logger = logging.getLogger(__name__)
        
        # デバッグ情報の出力
        logger.debug(f'現在の作業ディレクトリ: {os.getcwd()}')
        logger.debug(f'Pythonパス: {sys.path}')
        
        try:
            from core.database import DatabaseManager
            logger.info('DatabaseManagerをインポートしました')
            
            db = DatabaseManager()
            logger.info('DatabaseManagerを初期化しました')
            
            with db.get_connection() as conn:
                with conn.cursor() as cursor:
                    cursor.execute('SELECT 1 as test_value, NOW() as current_time')
                    result = cursor.fetchone()
                    logger.info(f'テストクエリ結果: {result}')
                    print('✅ データベース接続テストが成功しました')
        except ImportError as e:
            logger.error(f'モジュールのインポートに失敗: {e}')
            logger.error(f'現在のディレクトリ: {os.getcwd()}')
            current_dir = '.';
            logger.error(f'利用可能なファイル: {os.listdir(current_dir)}' if os.path.exists(current_dir) else 'ディレクトリが存在しません')
            print('❌ 必要なモジュールが見つかりません')
            sys.exit(1)
        except Exception as e:
            logger.error(f'データベース接続エラー: {e}')
            print(f'❌ データベース接続に失敗しました: {e}')
            sys.exit(1)
        "
    
    - name: バッチジョブの実行
      working-directory: batch
      env:
        # データベース関連
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        
        # 認証関連
        JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
        
        # X API関連の設定は削除済み
        
        # ログ設定
        LOG_LEVEL: ${{ github.event.inputs.log_level || 'INFO' }}
        
        # 実行制御
        FORCE_IMMEDIATE: ${{ github.event.inputs.force_immediate || 'false' }}
        
        # 実行環境
        ENVIRONMENT: 'production'
        GITHUB_RUN_ID: ${{ github.run_id }}
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: |
        # ジョブタイプの取得
        JOB_TYPE="${{ github.event.inputs.job_type || 'status-collection' }}"
        echo "🚀 バッチジョブを開始します: ${JOB_TYPE}"
        
        # ログディレクトリの作成
        mkdir -p logs
        
        # ジョブの実行
        case "${JOB_TYPE}" in
          "status-collection")
            echo "📊 稼働状況収集ジョブを実行中..."
            python main.py status-collection 2>&1 | tee logs/status-collection.log
            EXIT_CODE=${PIPESTATUS[0]}
            ;;

          "debug-html")
            echo "🔍 HTMLデバッグジョブを実行中..."
            python main.py debug-html --local-file "sample.html" 2>&1 | tee logs/debug-html.log
            EXIT_CODE=${PIPESTATUS[0]}
            ;;
          *)
            echo "❌ 不明なジョブタイプ: ${JOB_TYPE}"
            exit 1
            ;;
        esac
        
        # 実行結果の確認
        if [ ${EXIT_CODE} -eq 0 ]; then
          echo "✅ バッチジョブが正常に完了しました (終了コード: ${EXIT_CODE})"
        else
          echo "❌ バッチジョブが失敗しました (終了コード: ${EXIT_CODE})"
          echo "📋 失敗詳細情報:"
          echo "  - ジョブタイプ: ${JOB_TYPE}"
          echo "  - 実行時刻: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "  - 実行ID: ${{ github.run_id }}"
          echo "  - 実行番号: ${{ github.run_number }}"
          echo "  - ワークフロー: ${{ github.workflow }}"
          echo "  - リポジトリ: ${{ github.repository }}"
          echo "  - ブランチ: ${{ github.ref_name }}"
          
          # ログファイルの内容を出力（存在する場合）
          if [ -f "logs/${JOB_TYPE}.log" ]; then
            echo "📄 ログファイルの最後の50行:"
            echo "--- ログ開始 ---"
            tail -n 50 "logs/${JOB_TYPE}.log" || echo "ログファイルの読み取りに失敗"
            echo "--- ログ終了 ---"
          else
            echo "⚠️  ログファイルが見つかりません: logs/${JOB_TYPE}.log"
          fi
          
          # 環境情報の出力
          echo "🔧 環境情報:"
          echo "  - Python バージョン: $(python --version 2>&1)"
          echo "  - 作業ディレクトリ: $(pwd)"
          echo "  - ディスク使用量: $(df -h . | tail -1)"
          echo "  - メモリ使用量: $(free -h | head -2 | tail -1 || echo 'メモリ情報取得不可')"
          
          # サーバー拒否・bot検知対策の詳細情報
          echo "🚫 サーバー拒否・bot検知対策の詳細:"
          python - <<'PY'
          import sys, os, glob
          sys.path.append(".")
          try:
              from utils.config import Config
              from core.scraper import ScraperConfig
              config = Config()
              scraper_config = ScraperConfig()
              print("  📡 ネットワーク設定:")
              print(f"    - プロキシ有効: {getattr(scraper_config, 'use_proxy', '不明')}")
              print(f"    - プロキシローテーション: {getattr(scraper_config, 'proxy_rotation', '不明')}")
              print(f"    - User-Agent ローテーション: {getattr(scraper_config, 'ua_rotation', '不明')}")
              print(f"    - リクエスト間隔: {getattr(scraper_config, 'request_interval', '不明')}秒")
              print(f"    - タイムアウト設定: {getattr(scraper_config, 'timeout', '不明')}秒")
          except Exception as e:
              print(f"  ❌ 詳細情報の取得に失敗: {e}")
          PY
          
          exit ${EXIT_CODE}
        fi
    
    - name: ジョブ実行結果の要約
      if: always()
      working-directory: batch
      run: |
        echo "## 📋 ジョブ実行結果サマリー" >> $GITHUB_STEP_SUMMARY
        echo "- **ジョブタイプ**: ${{ github.event.inputs.job_type || 'status-collection' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **実行時刻**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        echo "- **実行ID**: ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
        echo "- **実行番号**: ${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
        
        # ログファイルの存在確認と要約
        if [ -d "logs" ] && [ "$(ls -A logs)" ]; then
          echo "- **生成されたログファイル**:" >> $GITHUB_STEP_SUMMARY
          for log_file in logs/*.log; do
            if [ -f "$log_file" ]; then
              file_size=$(stat -f%z "$log_file" 2>/dev/null || stat -c%s "$log_file" 2>/dev/null || echo "不明")
              echo "  - $(basename "$log_file") (${file_size} bytes)" >> $GITHUB_STEP_SUMMARY
            fi
          done
        else
          echo "- **ログファイル**: なし" >> $GITHUB_STEP_SUMMARY
        fi
    
    - name: ログファイルのアップロード
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: batch-logs-${{ github.event.inputs.job_type || 'status-collection' }}-${{ github.run_number }}
        path: batch/logs/
        retention-days: 30  # ログの保持期間
        if-no-files-found: warn
    
    - name: 失敗時の通知準備
      if: failure()
      run: |
        echo "FAILURE_SUMMARY=バッチジョブ '${{ github.event.inputs.job_type || 'status-collection' }}' が失敗しました (Run ID: ${{ github.run_id }})" >> $GITHUB_ENV
        echo "FAILURE_DETAILS=詳細はログファイルを確認してください。" >> $GITHUB_ENV
